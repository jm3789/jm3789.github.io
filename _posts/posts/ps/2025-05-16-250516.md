---
title: 다익스트라(Dijkstra) 알고리즘
description: 
date: 2025-05-16 15:38:22 +0900
categories:
  - PS
tags:
  - python
pin: false
comments: true
---
다익스트라 알고리즘은 **하나의 정점에서 출발해 다른 모든 정점까지의 최단거리를 구하는** 알고리즘이다. 대표적인 **그리디 알고리즘** 중 하나다. 모든 간선의 가중치가 0 이상의 양수일 때 사용할 수 있다.

[백준 1753. 최단경로](https://www.acmicpc.net/problem/1753)

## 🧠 과정

d 리스트에는 출발점으로부터 각 노드까지의 최단 거리가 저장된다. 

1. 모든 노드의 거리를 무한대(`inf`)로 초기화하고, 시작 노드의 인덱스(노드 번호와 동일)의 값만 0으로 설정한다.
2. 이후 아직 방문하지 않은 노드들 중에서, **현재 최단거리가 가장 짧은**(=출발점으로부터 가장 가까운, d에 들어가있는 값이 가장 작은) **노드 A를 선택**한다.
3. 노드 A와 연결된 모든 노드 B에 대해, `d[A] + (A와 B 사이의 거리)` 가 `d[B]`보다 작으면, `d[B]`를 해당 값으로 갱신한다.
4. 모든 B에 대해 이 작업을 마치면 A를 방문 완료 상태로 바꾼다.
5. 그다음 다시 아직 방문하지 않은 노드들 중에서 최단 거리가 가장 짧은 노드를 골라서 앞의 과정을 반복한다.
6. 모든 노드가 방문 완료 상태가 되면 알고리즘이 종료된다.

<br/>

---

## 작성 코드

```python
import sys
import heapq
input = sys.stdin.readline

V, E = map(int, input().split())
K = int(input())

d = [float('inf') for _ in range(V+1)]  # 인덱스가 노드 번호
d[K] = 0  # 시작 노드의 거리 초기화

# 각 노드와 연결되는 간선 정보 저장
edges = {}
for i in range(1, V+1):
    edges[i] = []  
for _ in range(E):
    u, v, w = map(int, input().split())
    edges[u].append((v, w))

pq = []  # 우선순위 큐: [거리, 노드번호] 형태로 저장. 가장 작은 거리의 노드 번호를 반환하도록
heapq.heappush(pq, [0, K])

while pq:
    dist, start = heapq.heappop(pq)  # 출발점으로부터 가장 작은 거리, 노드번호를 pop
    if d[start] < dist:  # 이미 방문한 노드인 경우 스킵
        continue

    for edge in edges[start]:  # start 노드와 연결된 간선에 대한 정보
        end = edge[0]
        weight = edge[1]
        # start 노드에서 end 노드로 가는 거리 갱신
        if d[start] + weight < d[end]:
            d[end] = d[start] + weight
            # 갱신된 거리와 노드번호를 우선순위 큐에 넣음
            heapq.heappush(pq, [d[end], end])

# 결과 출력
for i in range(1, len(d)):
    if d[i] == float('inf'):
        print("INF")
    else:
        print(d[i])
```

노드의 개수가 최대 20000개였기 때문에, 메모리 초과 방지를 위해 인접행렬 대신 인접리스트를 사용했다.

<br/>

---


## 💡 우선순위 큐(Priority Queue)

최단 거리가 가장 짧은 노드를 효율적으로 찾기 위해 우선순위 큐를 사용한다.

단순히 리스트를 순회해서 최단 거리 노드를 찾으면, 노드를 하나 처리할 때마다 `O(V)`시간이 걸리고, 이를 모든 노드(V)에 대해 반복하면 최종 시간 복잡도는 `O(V^2)`가 된다.

**하지만 heapq를 사용하면 최단 거리 노드를 `O(log V)`시간에 꺼낼 수 있다.**  모든 간선에 대해 최소 한 번씩은 큐 연산이 발생하므로, 최종 시간 복잡도는 `O(E log V)`로 줄어든다.

우선순위 큐에는 `[거리, 노드번호]` 형태로 넣어서, 꺼낼 때 해당 노드의 번호를 바로 알 수 있도록 구성했다.

### 🤔 의문

여기서 의문이 들 수 있다(내가 그랬다는 뜻 ㅎ)!

> 근데 거리 정보가 갱신될 때마다 pq 안에 있는 `[거리, 노드번호]`를 직접 수정해줘야 하는 거 아닌가? 이거 찾아서 바꿔주려면 되게 오래걸리지 않나? 이거 맞나?

**근데 그럴 필요가 없었다!** <br/>
어차피 새롭게 들어가는 정보가 더 짧은 값이라서, 어차피 그 값이 먼저 pop되기 때문이다. <br/>
**큐에 남아있는 옛날 값은 나중에 pop되더라도 이미 방문된 상태라는 걸 알 수 있기 때문에 무시해주면 된다.** 

이렇게 무시하면 된다:
```python
if d[start] < dist:
    continue
```

이 조건은, 현재 꺼낸 거리 `dist`가 `d[start]`보다 크다면 **이미 더 짧은 거리로 방문된 상태이므로 굳이 다시 처리하지 않겠다**는 의미다.<br/>
즉, 우선순위 큐 내부 값을 직접 수정할 필요 없이 자연스럽게 최신 정보만 반영할 수 있게 된다.

### 🧩 visited 배열 쓴다면?

근데 저 방법 대신 **visited 배열**을 따로 둬서 관리하는 게, 코드는 길어져도 가독성은 더 좋지 않나 싶기도 하다. <br/>
뭐가 더 좋을까? 챗지피티한테 물어봤다.

**🔥 삐티의 판단**

| ------ | -------------------- | ------------------------ |
| **항목** | **visited[]** **방식** | **d[now] < dist** **방식** |
| 코드 길이  | 길어짐                  | 짧고 깔끔                    |
| 가독성    | 명확한 방문 체크            | 거리 비교로 방문 판단             |
| 성능 차이  | 거의 없음                | 거의 없음                    |
| 추천     | **학습용**/**대회용**      | **실전 구현**/**빠른 코딩**      |

<br/>
성능 차이는 거의 없다고 한다… 왠지 그럴 거 같긴 하다(맹신).