

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>Jimin's Github Blog</title>
  <subtitle>안녕하세요</subtitle>
  <updated>2025-03-20T18:20:32+09:00</updated>
  <author>
    <name>Jimin Hong</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="ko"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator>
  <rights> © 2025 Jimin Hong </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>배낭 문제 (0/1 Knapsack Problem)</title>
    <link href="http://localhost:4000/posts/250319/" rel="alternate" type="text/html" title="배낭 문제 (0/1 Knapsack Problem)" />
    <published>2025-03-19T17:37:12+09:00</published>
  
    <updated>2025-03-19T17:37:12+09:00</updated>
  
    <id>http://localhost:4000/posts/250319/</id>
    <content src="http://localhost:4000/posts/250319/" />
    <author>
      <name>Jimin Hong</name>
    </author>

  
    
    <category term="PS" />
    
  

  <summary>코딩 테스트를 치르다가 배낭 같아보이는 문제를 만났지만 손도 못 대고 시험이 끝나버렸다. 배낭 알고리즘을 이해만 하고 넘어갔지, 직접 풀어본 적이 없었던 것 같다. 그래서 문제 몇 개를 직접 풀어보며 복습했다. 회고를 위해 이 글을 작성한다.

배낭 문제란?

배낭 문제(Knapsack Problem)는 다음과 같은 상황을 가정하는 문제이다.


  N개의 물건이 있다.
  각 물건은 특정한 무게(W)와 가치(V)를 가진다.
  최대 K 무게까지 담을 수 있는 배낭이 있다.
  배낭에 담을 수 있는 물건의 조합 중에서 가치의 합이 최대가 되도록 한다.


점화식

일반적으로 점화식은 이러한 형태다.
dp[i][j] = max(dp[i-1][j], dp[i-1][j-w] + v)


2차원 DP로 해결하...</summary>

  </entry>

  
  <entry>
    <title>[Go] API 계층별 역할</title>
    <link href="http://localhost:4000/posts/241122/" rel="alternate" type="text/html" title="[Go] API 계층별 역할" />
    <published>2024-11-22T00:20:22+09:00</published>
  
    <updated>2024-11-22T00:20:22+09:00</updated>
  
    <id>http://localhost:4000/posts/241122/</id>
    <content src="http://localhost:4000/posts/241122/" />
    <author>
      <name>Jimin Hong</name>
    </author>

  
    
    <category term="Memos" />
    
  

  <summary>이번 글에서는 병원 문진(question) 목록을 조회하는 API를 수정하는 과정에서 공부한 것들을 기록한다. 라우터-컨트롤러-서비스-레포지토리-DB로 이어지는 구조를 기반으로, 각 계층이 어떤 역할을 했는지 살펴보겠다.



1. 라우터 (Router)

라우터는 클라이언트 요청을 받아서 적절한 컨트롤러로 전달하는 역할을 한다. 병원 문진 조회 API에서는 다음과 같은 경로로 설정했다.

router.GET(&amp;quot;/admin/hospitalQuestion&amp;quot;, adminHospitalController.GetHospitalQuestionList)


라우터는 HTTP GET 메서드를 통해 병원 ID를 쿼리 파라미터로 받아 컨트롤러로 전달한다.



2. 컨트롤러 (Controller)

컨트롤러에서는 라우...</summary>

  </entry>

  
  <entry>
    <title>Go 서버에 로컬 MySQL 환경 세팅</title>
    <link href="http://localhost:4000/posts/241121/" rel="alternate" type="text/html" title="Go 서버에 로컬 MySQL 환경 세팅" />
    <published>2024-11-21T01:19:00+09:00</published>
  
    <updated>2024-11-21T01:42:44+09:00</updated>
  
    <id>http://localhost:4000/posts/241121/</id>
    <content src="http://localhost:4000/posts/241121/" />
    <author>
      <name>Jimin Hong</name>
    </author>

  
    
    <category term="Memos" />
    
  

  <summary>저번 편에서 이어진다.  
이번에는 AWS RDS에 연결되지 않는 상황에서 로컬 MySQL 환경을 설정하고 테스트한 과정을 정리해본다. 처음부터 직접 서버를 세팅하는 상황이 아니다보니, 서버를 다뤄본 경험이 부족한 나로서는 이게 제대로 공부되는 게 맞나 싶기도 하다. 그래도 기록을 남겨본다.



문제 상황

로컬 환경에서 서버를 실행하던 중 transaction is not initialized 오류를 만났다. 아직 데이터베이스와 연결되지 않은 상태에서 발생한 문제로 추정된다.

conf.ini 파일은 다음과 같이 설정되어 있었다.
[DebugDatabase] 
NumberOfDisk = 1 
Type = &amp;quot;mysql&amp;quot; 
User = &amp;quot;admin&amp;quot; 
Password = &amp;quot;안알랴줌&amp;quot; 
Host = &amp;quot;안...</summary>

  </entry>

  
  <entry>
    <title>Go 언어와 서버 실행하기</title>
    <link href="http://localhost:4000/posts/241119/" rel="alternate" type="text/html" title="Go 언어와 서버 실행하기" />
    <published>2024-11-19T00:55:00+09:00</published>
  
    <updated>2024-11-19T00:55:00+09:00</updated>
  
    <id>http://localhost:4000/posts/241119/</id>
    <content src="http://localhost:4000/posts/241119/" />
    <author>
      <name>Jimin Hong</name>
    </author>

  
    
    <category term="Memos" />
    
  

  <summary>Go 언어란?

Go 언어는 Google에서 개발한 오픈 소스 프로그래밍 언어이다. 간결한 문법을 바탕으로 효율적인 개발이 가능하다.

Go는 절차적 언어이면서도 객체지향 프로그래밍 요소를 일부 포함한다. 전통적인 객체지향 요소인 클래스나 상속이 없다. 대신 구조체와 메소드, 인터페이스를 통해 객체지향 프로그래밍을 지원한다.

구조체(Structs): Go에서는 클래스가 없는 대신 구조체에 메서드를 정의함으로써 객체와 비슷한 구성을 만들 수 있다.

type Person struct {
	Name string
	Age  int
}  

func (p *Person) Greet() string {
	return &amp;quot;Hello, &amp;quot; + p.Name 
}


메소드(Method): Go의 메소드에는 함수명 앞...</summary>

  </entry>

  
  <entry>
    <title>[JS] 백준 1927. 최소 힙</title>
    <link href="http://localhost:4000/posts/241116_1/" rel="alternate" type="text/html" title="[JS] 백준 1927. 최소 힙" />
    <published>2024-11-16T00:15:00+09:00</published>
  
    <updated>2024-11-16T00:15:00+09:00</updated>
  
    <id>http://localhost:4000/posts/241116_1/</id>
    <content src="http://localhost:4000/posts/241116_1/" />
    <author>
      <name>Jimin Hong</name>
    </author>

  
    
    <category term="PS" />
    
  

  <summary>백준 1927. 최소 힙

힙 (Heap)

힙은 이진 트리의 일종으로, 부모 노드와 자식 노드 간의 특정 관계를 유지하는 자료 구조이다. 힙은 완전 이진 트리 구조를 가지는데, 이는 트리가 항상 왼쪽부터 순차적으로 채워진다는 의미이다. 그래서 트리를 배열로 쉽게 표현하고 관리할 수 있다.

힙에는 두 가지 종류가 있다. 최소 힙과 최대 힙이다.

최소 힙 (Min Heap)

최소 힙은 부모 노드가 자식 노드보다 항상 작은 값을 가지는 완전 이진 트리이다. 최상단의 루트 노드는 항상 트리에서 가장 작은 값을 가진다. 새로운 요소가 추가되면 upheap 과정을 수행하고, 루트에 있던 최솟값이 삭제되면 가장 마지막에 있던 요소를 맨 앞으로 이동시킨 후 downheap 과정을 수행하여 힙의 규칙을 유지한다...</summary>

  </entry>

</feed>


