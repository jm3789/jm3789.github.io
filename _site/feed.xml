

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>Jimin's Github Blog</title>
  <subtitle>안녕하세요</subtitle>
  <updated>2025-05-12T17:34:19+09:00</updated>
  <author>
    <name>Jimin Hong</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="ko"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator>
  <rights> © 2025 Jimin Hong </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>파이썬의 선: pythonic함이란?</title>
    <link href="http://localhost:4000/posts/250422/" rel="alternate" type="text/html" title="파이썬의 선: pythonic함이란?" />
    <published>2025-04-22T17:48:45+09:00</published>
  
    <updated>2025-04-22T17:48:45+09:00</updated>
  
    <id>http://localhost:4000/posts/250422/</id>
    <content src="http://localhost:4000/posts/250422/" />
    <author>
      <name>Jimin Hong</name>
    </author>

  
    
    <category term="Memos" />
    
  

  <summary>평화롭던 어느 날-
챗지피티한테서 미션을 받았다.


  Zen of Python이라는 철학도 있어요. import this를 실행하면 볼 수 있답니다!



그래서 해봤다. 그랬더니 파이썬의 추구미(?)를 담은 시가 한 편 나왔다!

The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren&amp;#39;t s...</summary>

  </entry>

  
  <entry>
    <title>가상 메모리와 페이지 교체 알고리즘</title>
    <link href="http://localhost:4000/posts/250421/" rel="alternate" type="text/html" title="가상 메모리와 페이지 교체 알고리즘" />
    <published>2025-04-21T01:57:17+09:00</published>
  
    <updated>2025-04-21T01:57:17+09:00</updated>
  
    <id>http://localhost:4000/posts/250421/</id>
    <content src="http://localhost:4000/posts/250421/" />
    <author>
      <name>Jimin Hong</name>
    </author>

  
    
    <category term="CS" />
    
  

  <summary>정보처리기사 실기를 준비하면서 운영체제를 간략히 복습했다.



1. 운영체제 메모리 관리


  커널 적재(load)
  컴퓨터가 부팅되어 하드디스크나 SSD에 저장되어 있는 운영체제의 커널이
RAM(주기억장치)으로 복사되어 올라오는 것.
  
  가상 메모리(Virtual Memory)
  CPU는 RAM에 있는 데이터에만 직접 접근할 수 있다. 그래서 안 쓰는 애는 디스크에 잠깐 내려놓고, 필요해지면 다시 RAM에 올려서 쓰는 방식으로 데이터에 접근한다. 근데 운영체제는 마치 모든 게 메모리에 있는 것처럼 속여주고, 이것이 Virtual Memory의 개념이다. CPU가 메모리에 접근하기 위해서는 가상 메모리 주소를 실제 메모리 주소(물리 주소)로 변환하는 과정을 반복해야 한다.



주소 변환
...</summary>

  </entry>

  
  <entry>
    <title>[Python] 가장 긴 증가하는 부분 수열 (LIS)</title>
    <link href="http://localhost:4000/posts/250328/" rel="alternate" type="text/html" title="[Python] 가장 긴 증가하는 부분 수열 (LIS)" />
    <published>2025-03-27T23:44:54+09:00</published>
  
    <updated>2025-03-27T23:44:54+09:00</updated>
  
    <id>http://localhost:4000/posts/250328/</id>
    <content src="http://localhost:4000/posts/250328/" />
    <author>
      <name>Jimin Hong</name>
    </author>

  
    
    <category term="PS" />
    
  

  <summary>LIS(Longest Increasing Subsequence) 알고리즘

주어진 수열에서 일부 원소를 제거해 순서를 유지한 채 가장 길게 증가하는 부분 수열을 찾는 문제다.
O(N^2) 풀이(DP)와 O(N log N) 풀이(이분 탐색)가 있다.



1️⃣ DP 풀이 (O(N^2))

문제: 백준 11053번

# dp
N = int(input())
dp = [0 for _ in range(N+1)]  
# dp[i]: i번째 원소를 마지막으로 하는 증가하는 부분 수열들 중 가장 긴 것의 길이

A = [0] + list(map(int, input().split()))
for i in range(1, N+1):
    max_num = 0
    for j in range(i):
        if...</summary>

  </entry>

  
  <entry>
    <title>소프트웨어 마에스트로 16기 면접 후기(탈락)</title>
    <link href="http://localhost:4000/posts/250323/" rel="alternate" type="text/html" title="소프트웨어 마에스트로 16기 면접 후기(탈락)" />
    <published>2025-03-23T22:25:41+09:00</published>
  
    <updated>2025-03-28T15:37:09+09:00</updated>
  
    <id>http://localhost:4000/posts/250323/</id>
    <content src="http://localhost:4000/posts/250323/" />
    <author>
      <name>Jimin Hong</name>
    </author>

  
    
    <category term="Memos" />
    
  

  <summary>운 좋게 소마 최종 면접까지 가게 되었다! 내 머릿속에서 소마의 이미지는 엄청난 실력자 분들이 굉장한 서비스를 만들어내는 곳이었다보니, 내가 최종 면접까지 가게 되었다는 게 믿기지 않았다. 꼭 합격하고 싶었다. 그래서 일주일 정도 열심히 준비했다.

면접 장소 및 일정


  
    위치: 포스트타워마포 (마포대로 89, 서울마포우체국) 7층
  
  
    일시: 3월 23일 (일) 오전 10시 ~ 11시 15분
  
  
    입실: 면접 시작 30분 전부터 대기장 입실 가능
  
  
    준비물: 주민등록증 필수, 물도 챙겨가면 좋다 (면접 중간에 마실 수 있음)
  


면접 시작 전

7층에 도착해서 엘리베이터 문이 열리자마자 바로 앞에 스태프분들이 앉아 계셨다. 이름을 물어보셔서 말...</summary>

  </entry>

  
  <entry>
    <title>배낭 문제 (0/1 Knapsack Problem)</title>
    <link href="http://localhost:4000/posts/250319/" rel="alternate" type="text/html" title="배낭 문제 (0/1 Knapsack Problem)" />
    <published>2025-03-19T17:37:12+09:00</published>
  
    <updated>2025-03-19T17:37:12+09:00</updated>
  
    <id>http://localhost:4000/posts/250319/</id>
    <content src="http://localhost:4000/posts/250319/" />
    <author>
      <name>Jimin Hong</name>
    </author>

  
    
    <category term="PS" />
    
  

  <summary>코딩 테스트를 치르다가 배낭 같아보이는 문제를 만났지만 손도 못 대고 시험이 끝나버렸다. 배낭 알고리즘을 이해만 하고 넘어갔지, 직접 풀어본 적이 없었던 것 같다. 그래서 문제 몇 개를 직접 풀어보며 복습했다. 회고를 위해 이 글을 작성한다.

배낭 문제란?

배낭 문제(Knapsack Problem)는 다음과 같은 상황을 가정하는 문제이다.


  N개의 물건이 있다.
  각 물건은 특정한 무게(W)와 가치(V)를 가진다.
  최대 K 무게까지 담을 수 있는 배낭이 있다.
  배낭에 담을 수 있는 물건의 조합 중에서 가치의 합이 최대가 되도록 한다.


점화식

일반적으로 점화식은 이러한 형태다.
dp[i][j] = max(dp[i-1][j], dp[i-1][j-w] + v)


2차원 DP로 해결하...</summary>

  </entry>

</feed>


